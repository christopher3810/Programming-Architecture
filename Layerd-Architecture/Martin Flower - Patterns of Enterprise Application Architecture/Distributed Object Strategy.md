
>객체가 만들어진 지는 이제 꽤 많은 시간이 흘렀고 객체가 처음 선보인 이후로 많은 사람들이 객체를 분산하려는 노력을 했다.\
>그러나 객체를 분산하는 작업에는 사람들이 생각하는 것 이상으로 많은 함정이 도사리고 있다.

>고객 , 주문, 제품, 배송을 위한 원격 객체가 각각 분리 돼있고, 각 객체는 별도의 프로세싱 노드에 배치할 수 있는 별도의 컴포넌트다.

> 이렇게 하는 이유가 뭐죠?\
> 당연히 성능이죠. 각 컴포넌트는 별도의  시스템에서 실행할수 있습니다.\
> 한 컴포넌트의 작업량이 많아지면 시스템을 추가해서 애플리케이션의 부하를 분산하는 것 입니다.\

>필자는 이 분산 아키텍처가 왜 형편없는 설계라고 생각하는 것일까?

>강력한 미들웨어가 투명성을 제공한다고 말한다.\
>투명성은 호출하려는 대상이 동일한 프로세스나 다른 프로세스 또는 다른시스템에 있느냐와 관계없이 객체가 다른 객체를 한프로세스 안이나 프로세스 간에 호출할 수 있게 해주는 개념이다.\
>투명성을 가치가 높고, 분산 객체의 여러 측면에 긍정적 영향을 주지만 일반적으로 성능에는 긍정적 영향을 주지 않는다.\
>실제로 성능이 오히려 저하되며 시스템의 구축이나 배포도 훨씬 어려워진다.

>클래스 모델별 분산이 좋지 않은 생각이라고 말하는 주된 이유는 컴퓨터의 기본 작동 원리 때문이다.\
>한 프로세스 내의 프로시저 호출은 극도로 빠르지만 분리된 프로세스 간의 프로시저 호출은 이보다 수십 또는 수백배 느리다.\
>게다가 다른 시스템에서 실행중인 프로세스에 대한 프로시저 호출은 네트워크 토폴로지에 따라 다시 수십 또는 수백 배 느려진다.

>로컬 인터페이스는 fine-grained interface일 때가 가장 좋다.\
>주소 클래스의, 시 getter, 도 getter, 등 메서드가 모두 별도로 존재하는 케이스다.\
>fine-grained interface가 바람직한 이유는 다양한 방법으로 재정의 하고 결합해 향후에 설계를 확장할 수 있는 작은 조각으로 정의하는 객체지향의 일반적 규칙을 따르기 때문이다.\
>그러나 fine-grained interface는 원격 환경에 잘 맞지 않는다.\
>메서드 호출이 느리기 때문이다.\
>한 번의 호출로 한꺼번에 얻거나, 업데이트 하고 싶을것이기 때문이다.\
>결과적으로 인터페이스는 유연성이나 확장성이 아닌 호출 횟수 최소화를 위한 find 하지 않은 grained interface가 된다.

>두 객체가 별도의 프로세스에서 통신할 가능성이 있다면 굵은 grained interface를 사용하고 어려운 프로그래밍 모델이라는 비용을 치뤄야 한다.\
>결과적으로 프로세스간 공동작업을 최소화할 필요가 있다.

>그래서 필자는 객체를 분산하지 말라 를 분산 객체 설계의 첫 번쨰 규칙으로 제시한다.

### 다중 프로세서를 효과적으로 사용하려면?
---

>일반적으로 클러스터링이 가장 적합하다.\
>모든 클래스를 단일 프로세스에 넣고 해당 프로세스의 여러 복사본을 다수의 노드에서 실행하는 것이다.

### 분산이 필요한 상황
---

>프로세스를 분리해야 하는 상황이 존재한다.\

>한가지 확실한 분리는 비즈니스 소프트웨어에서 전통적인 클라이언트와 서버간 분리다.

>두 번째 분리는 서버 기반 애플리케이션 소프트웨어와 데이터베이스 간에 자주 볼수 있다.\

>웹 서버와 애플리케이션 서버 간에도 프로세스 분리가 필요할 수 있다.

>마지막으로 애플리케이션 서버 소프트웨어를 분리해야 하는 합당한 이유가 있는 경우다.\
>마음을 굳게 먹고 원격의 굵은 입자 컴포넌트로 나눈다.

>정리하면 객체 분산은 도무지 방법이 없을 때 사용하는 최후의 수단으로 미뤄야 한다.

아직까지도 이러한 생각들은 유효하다고 생각한다.

MSA와 같은 프로세스 분리가 필요한 분산 객체 형태의 아키텍쳐는 자체적인 복잡성과 통신비용 그리고 인프라비용을 항상 몰고 온다.

martin fowler가 말한 것과 같이 분산 객체간 Interface 가 굵은 형태의 interface의 형태를 띄게 되고 어려운 프로그래밍 모델을 가져올 수있다.

그렇다고 MSA가 무조건 안좋고 복잡한 Arcitecture 인가? 

또 그것도아니다 설계는 항상 trade off가 존재하며.

MSA는 아키텍쳐적 변경이 아니라 시스템 아키텍쳐가 못버티고 비명을 지르다 전환하는 하나의과정이라고 생각이 든다.

프로세스 분리로 인해서 일정수준의 trade off를 고려하고도 부하가 몰리는 특정 도메인 객체 시스템에 있어서 성능적 이점을 가져다 주기도 한다.

포인트는 MSA에서도 서비스 경계를 신중하게 설정하고, 불필요한 분산을 피하는 것이 중요하다는 것.

### 분산 경계를 사용한 작업
---

>모든 원격 호출은 추가 비용을 지불하고 실행 된다.\
>따라서 이 원격 호출을 최소화 하려면 시스템의 모든 부분이 달라져야 한다.

>굵은 입자 객체는 위임 외의 다른 일은 하지 않으므로 가는 입자 객체에 대한 facade라고 할 수 있다.\
>이 facade는 분산 용도로만 사용되므로 원격 facade라고 한다.


>[!Note]
>원격 파사드\
>가는 입자 객체에 대한 굵은 입자 파사드를 제공해 네트워크 상에서 효율을 향상시킨다.

>원격 파사드를 이용하면 굵은 입자 인터페이스를 사용 할 때의 어려움을 최소화 하는데 도움이 된다.\
>정말 필요한 객체만 굵은 입자 메서드를 사용하게 하면 이러한 객체에서 발생하는 부가 비용을 합리적으로 이해할 수 있다.\
>투명성에는 분명히 장점이 있지만, 잠재적 원격 호출은 투명하게 처리할 대상이 아니다.

>굵은 입자 메서드만 필요한 거싱 아니라 굵은 입자 객체를 전송하는 기능도 필요하다.\
>예를 들어, 주소를 요청받으면 이 정보를 한 블록으로 전달해야 한다.\
>일반적으로 도메인 객체 자체를 전송할 수는 없다.\
>따라서 클라이언트가 필요로 하는 모든 데이터를 가져와 전송하기 적합한 객체, 즉 데이터 전송 객체를 만들어야 한다.

>[!note]
>데이터 전송 객체\
>메서드 호출 횟수를 줄이기 위해 프로세스 간에 데이터를 전송하는 객체.

>데이터 전송 객체는 전송 전후 양쪽에서 모두 사용되므로 양쪽에서 공유하지 않는 것을 참조하지 않아야 한다.\
>데이터 전송 객체는 일반적으로 다른 데이터 전송객체 와 문자열 등의 기본 객체만 참조하게 된다.

### 분산을 위한 인터페이스
---

>분산 컴포넌트의 인터페이스는 전통적으로 rpc에 기반을 두는 경우가 많다.

>xml over http에 기반을 두는 interface가 나타나기 시작했다.\
>SOAP는 가장 흔한 형태이다.

>xml 기반 http 통신에는 여러 장점이 있다.\
>가장 큰 장점은 많은 양의 데이터를 구조화된 형식을 통해 단 한번의 왕복으로 손쉽게 전송할 수 있다는 것이다.\
>이런 특성은 원격 호출을 최소화 하는데 도움이 된다.

>지금까지 필자는 동기식 RPC 기반 인터페이스를 사용한다고 가정했다.\
>그러나 동기식 RPC 기반 인터페이스가 분산 시스템을 운영하는 최상의 방법이라고 생각하지는 않는다.

>비동기적인 메시지 기반 방식이 더 좋다고 생각하고 있다.\
>필자는 비동기 메시지 기반 방식이 웹서비스를 가장 잘활용하는 방법이라고 생각한다.

